"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@auto-it/core");
const util_1 = require("util");
const t = tslib_1.__importStar(require("io-ts"));
const fs = tslib_1.__importStar(require("fs"));
const semver_1 = require("semver");
const readFile = util_1.promisify(fs.readFile);
const writeFile = util_1.promisify(fs.writeFile);
const pluginOptions = t.partial({
    /** Path to file (from where auto is executed) where the version is stored */
    versionFile: t.string,
    /** Optional script that executes release pipeline stages */
    publishScript: t.string,
    /** Optional publish script args mapping for each release hook, defaults `publish` to ["release"] and the others to ["snapshot"] */
    publishScriptReleaseTypeArgs: t.partial({
        publish: t.array(t.string),
        canary: t.array(t.string),
        next: t.array(t.string),
    })
});
/**
 * Reads version file from location specified in config
 */
async function getPreviousVersion(auto, versionFile) {
    auto.logger.veryVerbose.info(`Reading version from file `, versionFile);
    return readFile(versionFile, "utf-8");
}
/** Writes new version to version file at specified location */
async function writeNewVersion(auto, version, versionFile) {
    auto.logger.veryVerbose.info(`Writing version to file `, versionFile);
    return writeFile(versionFile, version);
}
/** Reset the scope changes of all the packages  */
async function gitReset(auto) {
    auto.logger.veryVerbose.info("Hard resetting local changes");
    await core_1.execPromise("git", ["reset", "--hard", "HEAD"]);
}
/** Generates canary release notes */
function makeCanaryNotes(canaryVersion) {
    return `Try this version out locally by upgrading relevant packages to ${canaryVersion}`;
}
/**  Plugin to orchestrate releases in a repo where version is maintained in a flat file */
class VersionFilePlugin {
    /** Initialize the plugin with it's options */
    constructor(options) {
        var _a, _b;
        /** The name of the plugin */
        this.name = 'version-file';
        this.versionFile = (_a = options.versionFile) !== null && _a !== void 0 ? _a : "VERSION";
        this.publishScript = options.publishScript;
        this.publishScriptReleaseTypeArgs = Object.assign({ publish: ['release'], canary: ['snapshot'], next: ['snapshot'] }, (_b = options.publishScriptReleaseTypeArgs) !== null && _b !== void 0 ? _b : {});
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        var _a;
        const prereleaseBranches = ((_a = auto.config) === null || _a === void 0 ? void 0 : _a.prereleaseBranches) || core_1.DEFAULT_PRERELEASE_BRANCHES;
        const branch = core_1.getCurrentBranch();
        // if ran from baseBranch we publish the prerelease to the first
        // configured prerelease branch
        const prereleaseBranch = branch && prereleaseBranches.includes(branch)
            ? branch
            : prereleaseBranches[0];
        auto.hooks.validateConfig.tapPromise(this.name, async (name, options) => {
            // If it's a string thats valid config
            if (name === this.name && typeof options !== "string") {
                return core_1.validatePluginConfiguration(this.name, pluginOptions, options);
            }
        });
        auto.hooks.getPreviousVersion.tapPromise(this.name, () => {
            return getPreviousVersion(auto, this.versionFile);
        });
        auto.hooks.version.tapPromise(this.name, async ({ bump }) => {
            const lastVersion = await getPreviousVersion(auto, this.versionFile);
            const newVersion = semver_1.inc(lastVersion, bump);
            auto.logger.log.info(`Calculated new version as: ${newVersion}`);
            if (newVersion) {
                // Seal versions via commit and tag
                await writeNewVersion(auto, newVersion, this.versionFile);
                const prefixedVersion = auto.prefixRelease(newVersion);
                await core_1.execPromise("git", ["commit", "-am", `"Bump version to: ${prefixedVersion} [skip ci]"`]);
                await core_1.execPromise("git", [
                    "tag",
                    prefixedVersion
                ]);
                auto.logger.verbose.info("Successfully versioned repo");
            }
            else {
                auto.logger.log.error(`Error: Unable to calculate new version based off of ${lastVersion} being bumped with a ${bump} release`);
                throw new Error("Version bump failed");
            }
        });
        auto.hooks.publish.tapPromise(this.name, async () => {
            // Call release script if provided
            if (this.publishScript) {
                auto.logger.log.info(`Calling release script in repo at ${this.publishScript}`);
                await core_1.execPromise(this.publishScript, this.publishScriptReleaseTypeArgs.publish);
            }
            else {
                auto.logger.log.info("Skipping calling release script in repo since none was provided");
            }
            // push tag and version change commit up
            await core_1.execPromise("git", ["push", auto.remote, branch || auto.baseBranch, "--tags"]);
        });
        auto.hooks.canary.tapPromise(this.name, async ({ bump, canaryIdentifier }) => {
            var _a;
            // Figure out canary version
            const lastRelease = (await auto.git.getLatestRelease()) ||
                (await ((_a = auto.git) === null || _a === void 0 ? void 0 : _a.getLastTagNotInBaseBranch(prereleaseBranch))) ||
                (await getPreviousVersion(auto, this.versionFile));
            const current = await auto.getCurrentVersion(lastRelease);
            const nextVersion = semver_1.inc(current, bump);
            const canaryVersion = `${nextVersion}-${canaryIdentifier}`;
            auto.logger.log.info(`Marking version as ${canaryVersion}`);
            // Write Canary version
            await writeNewVersion(auto, canaryVersion, this.versionFile);
            // Ship canary release if release script is provided
            if (this.publishScript) {
                auto.logger.log.info(`Calling release script in repo at ${this.publishScript}`);
                await core_1.execPromise(this.publishScript, this.publishScriptReleaseTypeArgs.canary);
            }
            else {
                auto.logger.log.info("Skipping calling release script in repo since none was provided");
            }
            // Reset temporary canary versioning
            await gitReset(auto);
            return {
                newVersion: canaryVersion,
                details: makeCanaryNotes(canaryVersion),
            };
        });
        auto.hooks.next.tapPromise(this.name, async (preReleaseVersions, { bump }) => {
            var _a, _b;
            // Figure out next version
            const lastRelease = await auto.git.getLatestRelease();
            const currentBranch = await core_1.getCurrentBranch();
            const latestTagInBranch = await (currentBranch === auto.baseBranch
                ? (_a = auto.git) === null || _a === void 0 ? void 0 : _a.getLatestTagInBranch()
                : (_b = auto.git) === null || _b === void 0 ? void 0 : _b.getLastTagNotInBaseBranch(prereleaseBranch));
            const latestTag = latestTagInBranch ||
                (await getPreviousVersion(auto, this.versionFile));
            const nextVersion = core_1.determineNextVersion(lastRelease, latestTag, bump, prereleaseBranch);
            const prefixedVersion = auto.prefixRelease(nextVersion);
            preReleaseVersions.push(prefixedVersion);
            auto.logger.log.info(`Marking version as ${prefixedVersion}`);
            // Write version to file
            await writeNewVersion(auto, prefixedVersion, this.versionFile);
            // ship next release if release script is provided
            if (this.publishScript) {
                auto.logger.log.info(`Calling release script in repo at ${this.publishScript}`);
                await core_1.execPromise(this.publishScript, this.publishScriptReleaseTypeArgs.next);
            }
            else {
                auto.logger.log.info("Skipping calling release script in repo since none was provided");
            }
            // Push next tag
            await core_1.execPromise("git", [
                "tag",
                prefixedVersion
            ]);
            await core_1.execPromise("git", ["push", auto.remote, branch, "--tags"]);
            return preReleaseVersions;
        });
    }
}
exports.default = VersionFilePlugin;
//# sourceMappingURL=index.js.map